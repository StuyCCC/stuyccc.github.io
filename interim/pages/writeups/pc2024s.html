<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../../templates/template.css" type="text/css">
    <link rel="icon" href="../../templates/favicon.ico">
    <script src="../../templates/template.js"></script>

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../templates/gruvbox-dark-pale.min.css">
    <script src="../../templates/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
	

    <title>StuyCCC</title>
</head>

<body>

  
    <div id="side"></div>
    <div id="main">
        <h4>Last Updated 2024-04-10</h4>
        <fieldset>
            <legend>PCLASSIC 2024 Spring</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <p>
                If you'd like to view the problems:<br>
                <a href="https://tinyurl.com/pcl24SPclassic">PClassic 2024 Spring Classic</a><br>
                <a href="https://tinyurl.com/pcl24SPadvanced">PClassic 2024 Spring Advanced</a><br>
                Classic has problems 1 through 8, while Advanced has problems 5 through 12.<br>
            </p>
			
						<h2><a target="_blank" href="https://codeforces.com/gym/516048/problem/A">Problem 01 - Great Golden 'Graph</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">
// written by Chongtian Ma 
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main(){
	string s; int k; cin &gt;&gt; s &gt;&gt; k;
	cout &lt;&lt; s[(k - 1) % s.length()] &lt;&lt; endl;
}
</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
				<span style="white-space: pre-line"><p>
                We are looking for the character at position <script type="math/tex">r</script> where <script type="math/tex">r</script> is the remainder when <script type="math/tex">k</script> is divided by the length of <script type="math/tex">s</script>. Note that since strings are 0-indexed, you must subtract <script type="math/tex">1</script> from <script type="math/tex">k</script> before you take modulo.
                </p>
            </details>
			
			
			<h2><a target="_blank" href="https://codeforces.com/gym/516048/problem/B">Problem 02 - Cowculated Cattle Combining</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">
// written by Chongtian Ma 
#include &lt;iostream&gt;
using namespace std;

int main(){
	int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
	if((a * b) - c == 0 || (a * c) - b == 0 || (b * c) - a == 0 ||
	   a * (b - c) == 0 || a * (c - b) == 0 || b * (c - a) == 0 || (a - b) * c == 0){
		cout &lt;&lt; "YES" &lt;&lt; endl;
	}
	else{
		cout &lt;&lt; "NO" &lt;&lt; endl;
	}
}
</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
				<span style="white-space: pre-line"><p>
                There are several approaches to this problem. You could either list out all the possible cases and orderings like I did, or use std::next_permutation to iterate through all permutations of an array with elements {a, b, c}, and take the maximum of the expressions over all permutations.
                </p>
            </details>
			
			</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
				<span style="white-space: pre-line"><p>
                We are looking for the character at position <script type="math/tex">r</script> where <script type="math/tex">r</script> is the remainder when <script type="math/tex">k</script> is divided by the length of <script type="math/tex">s</script>. Note that since strings are 0-indexed, you must subtract <script type="math/tex">1</script> from <script type="math/tex">k</script> before you take modulo.
                </p>
            </details>
			
			
	<h2><a target="_blank" href="https://codeforces.com/gym/516048/problem/C">Problem 03 - Shooter Sheriff Showdown</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">
// written by Chongtian Ma 
#include &lt;iostream&gt;
using namespace std;

int main(){
	int n, x; cin &gt;&gt; n &gt;&gt; x;
	cout &lt;&lt; n / (x + 1) &lt;&lt; endl;
}
</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
				<span style="white-space: pre-line"><p>
					Let's denote the answer to be  <script type="math/tex">c</script>. From the samples, you could probably see that since you could leave a length <script type="math/tex">c</script> gap at the start, <script type="math/tex">n</script> could actually be shortened by <script type="math/tex">c</script>, assuming we are to place a D on the first slot. So, we want to solve for the maximum <script type="math/tex">c</script> such that <script type="math/tex">\frac{n - c}{c} \geq x</script>.
					
					Rearraging the equation we will arrive at <script type="math/tex">\frac{n}{x+1} \geq c</script>. Since  <script type="math/tex">c</script> can be at most <script type="math/tex">\frac{n}{x+1}</script>, that is our answer.
                </p>
            </details>
			
			
			<h2><a target="_blank" href="https://codeforces.com/gym/516050/problem/B">Problem 06 - Stupid Slow Stagecoaches</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">
// written by Chongtian Ma 
#include &lt;bits/stdc++.h&gt;
using namespace std;

void solve(){
	int n; cin &gt;&gt; n;
	vector&lt;pair&lt;int, int&gt;&gt; v(n);
	for(int i = 0; i &lt; n; i++){
		cin &gt;&gt; v[i].first;
	}
	for(int i = 0; i &lt; n; i++){
		cin &gt;&gt; v[i].second;
	}
	int slowest_speed = 1e9, ans = 0;
	for(int i = n - 1; i &gt;= 0; i--){
		if(v[i].second &lt; slowest_speed){
			ans++;
			slowest_speed = v[i].second;
		}
	}
	cout &lt;&lt; ans &lt;&lt; "\n";
}

int main(){
	cin.tie(0) -&gt; sync_with_stdio(0);
	int t = 1;
	cin &gt;&gt; t;
	while(t--){
		solve();
	}
}

/*   /\_/\
*   (= ._.)
*   / &gt;  \&gt;
*/
</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
				<span style="white-space: pre-line"><p>
                Observe that a stagecoach will only join a cluster if the stagecoach infront has a strictly slower speed. Once it joins the cluster, its velocity will inherit the slower stagecoach's. Note that the x-positions of the stagecoaches does not actually matter because with infinite amount of time, a faster stagecoach behind a slower stagecoach will always catch up. Let's generalize this to all stagecoaches.
				
				If there is a series of <script type="math/tex">k</script> stagecoaches with velocities <script type="math/tex">v_1, v_2, ... v_k</script> such that <script type="math/tex">v_k < \min(v_1, v_2, ... v_{k-1})</script>, then the <script type="math/tex">k</script> stagecoaches will form a cluster moving at velocity <script type="math/tex">v_k</script>. With infinite amount of time, with each cluster <script type="math/tex">k</script> should be as big as possible. Since only the velocity of the last stagecoach matter, this prompts us to loop backwards - from the rightmost stagecoach to the left.
				
				We can track a global minimum velocity <script type="math/tex">v_{min}</script>. In our loop, if we encounter a stagecoach with velocity less than <script type="math/tex">v_{min}</script>, then that stagecoach must form a separate cluster. Thus, we can solve this problem in <script type="math/tex">\mathcal{O}(n)</script> time.
                </p>
            </details>
			
<h2><a target="_blank" href="https://codeforces.com/gym/516050/problem/C">Problem 07 - Dire Debt Dilemma </a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">
// written by Victor Casado
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;array&gt; 
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
    int n;
    cin &gt;&gt; n;
    bool nOdd;

    int array[n];

    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; array[i];
    }

    int med;
    int h = sizeof(array)/sizeof(array[0]);
    sort(array,array+h);
    if(n % 2 == 1){
        med = array[n/2];
    }
    else{
        med = (array[n/2] + array[(n/2)-1])/2;
    }

    int r = 0;
    for(int i = 0; i &lt; n; i++){
        r+= abs((array[i]-med));
    }
    cout&lt;&lt;r&lt;&lt;"\n";
}
</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
				<span style="white-space: pre-line"><p>
                Essentially, the problem gives you a list of numbers, and wants you to find the minimum amount of total change done to these numbers to make them all the same number. Thus, you have to pick a number to make them all become.

Crucially, it can be shown that this number is the median of all the numbers. (For any 2 numbers, any number between them will create the same amount of change. Extending this pattern to more numbers makes it clear the median is the optimal choice). 

Thus, we loop through the numbers and store them in an array, and then we find the median. Then, we loop through the array and find the differences to the median. The sum of these differences is our result. 
                </p>
            </details>
			
			
            <h2><a target="_blank" href="https://codeforces.com/gym/516050/problem/D">Problem 08 - Tantilizing Tile Transformations</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">//written by Matthew Chen
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define sz(x) (int)(x).size()
#define FOR(i,s,e) for (int i = (s); i &lt; (e); ++i) 
#define F0R(i,e) FOR(i,0,e) 
template&lt;typename T&gt; istream& operator&gt;&gt;(istream& in, vector&lt;T&gt;& a) {for(auto &x: a) in &gt;&gt; x; return in;};
    
int mx(array&lt;int,4&gt; x) {//max of 0,1,2 color freq's
    return max(x[0], max(x[1], x[2]));
}
void solve() {
    int n; cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(n));
    cin &gt;&gt; grid;

    //{0, 1, 2, total}
    vector&lt;array&lt;int,4&gt;&gt; row(n), col(n);//frequencies
    vector&lt;pair&lt;int,int&gt;&gt; sweep;
    F0R(i,n) {
        row[i][3] = col[i][3] = n;
        F0R(j,n) {
            row[i][grid[i][j]]++;
            col[j][grid[i][j]]++;
        }
    }
    //populate sweep
    F0R(i,n) {
        if (mx(row[i]) == row[i][3] && mx(row[i]) != row[i][0]) {
            sweep.push_back({i,0ll});
        }
    }
    F0R(j,n) {
        if (mx(col[j]) == col[j][3] && mx(col[j]) != col[j][0]) {
            sweep.push_back({j,1ll});
        }
    }
    vector&lt;array&lt;int,3&gt;&gt; ans;//{row/col type, ind, color}
    while (sz(sweep)) {
        for (auto [ind,typ]: sweep) {
            if (typ == 0) {//process row
                F0R(j,n) if (col[j][3] != 0) {//update cols
                    col[j][grid[ind][j]]--;
                    col[j][3]--;
                }
                int color = 0;
                if (row[ind][1] == mx(row[ind])) color = 1;
                else if (row[ind][2] == mx(row[ind])) color = 2;
                ans.push_back({typ, ind+1, color});
                row[ind] = {0,0,0,0};//delete row
            }
            else {//process col
                F0R(i,n) if (row[i][3] != 0){//update rows
                    row[i][grid[i][ind]]--;
                    row[i][3]--;
                }
                int color = 0;
                if (col[ind][1] == mx(col[ind])) color = 1;
                else if (col[ind][2] == mx(col[ind])) color = 2;
                ans.push_back({typ, ind+1, color});
                col[ind] = {0,0,0,0};//delete col
            }
        }
        sweep.clear();
        //repopulate sweep with new rows/cols
        F0R(i,n) {
            if (mx(row[i]) == row[i][3] && mx(row[i]) != row[i][0]) {
                sweep.push_back({i, 0});
            }
        }
        F0R(j,n) {
            if (mx(col[j]) == col[j][3] && mx(col[j]) != col[j][0]) {
                sweep.push_back({j, 1});
            }
        }
    }
    //check for impossible case
    F0R(i,n) {
        if (row[i][1] || row[i][2] || col[i][1] || col[i][2]) {
            cout &lt;&lt; -1 &lt;&lt; '\n'; return;
        }
    }
    reverse(ans.begin(), ans.end());
    cout &lt;&lt; sz(ans) &lt;&lt; '\n';
    for (auto [a,b,c]: ans) {
        cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; '\n';
    }
}
</code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
                <span style="white-space: pre-line"><p>The problem wants you to reconstruct a sequence of transformations which color a row or column as 1 or 2 such that the resulting grid matches with the given grid. 
                    
                    Our solution will go backwards to revert the given grid into a blank grid of 0's. For simplicity, let's assume the grid is guaranteed to have a solution and we'll deal with the impossible case later.
                    
                    Obviously, there will be some rows or columns with only one color which we can process first. You can imagine that "processing" a row or column as just completely eliminating that row/col from the grid, and snipping the two halves of the grid back together. This is because we can just uncolor that row/col and arbitrarily set the color underneath to fit our situation. 
                    
                    After processing the "obvious" row/col's, it is guaranteed that the concatenated grid will have new "obvious" row/col's to eliminate since the grid has a guaranteed solution. Now, we can rinse and repeat: eliminate those row/col's and snip the grid back together.
                    
                    As for the case where a solution does not exist, that will be when after eliminating a set of "obvious" row/col's, there exists no more row/col's to process and the grid itself has not become 0.
                    
                    Overall, the visualization is decently intuitive, the implementation is a bit more tedious though.
                
                    Let's maintain 4 additional vectors, <code>row</code>, <code>col</code>, <code>sweep</code>, and <code>ans</code>, aside from our given input grid.

                    <code>row</code> and <code>col</code> will store 4 numbers per row/col, the color frequencies of 0,1,2, and the total number of cells in that row/col (you'll see why we want to keep track of this).
                    <code>sweep</code> will store the rows and columns that we will want to eliminate from the grid.
                    <code>ans</code> will store the sequence of moves that will be our answer.
                    
                    Initially, <code>sweep</code> will contain the "obvious" rows and columns that we can easily eliminate. 
                    We will run through iterations until <code>sweep</code> becomes empty
                    
                    In each iteration, process each of the row/col's in <code>sweep</code>. When we process row <code>i</code> for example, we have to update all of the columns. Let the color of that row be <code>c</code> and each column be <code>j</code>, we will decrement both the frequency of <code>c</code> and the total number of cells in <code>col[j]</code> by 1. Processing a column is also similar but swapped.
                    
                    When we process a row/col, we will delete that from <code>sweep</code> and also push that information into <code>ans</code>
                    
                    Then, we will go through each row and column and see if all of the total cells are a single color. If so, we will push those new rows and columns into <code>sweep</code>.
                    
                    Once there are no more new rows and columns to push into sweep, we are done.
                    All that is left to check is whether there are any nonzero colors in <code>row</code> and <code>col</code>.
                    
                    The time complexity is <script type="math/tex">\mathcal{O}(n^2)</script> since there are <script type="math/tex">n</script> rows, each of which affects <script type="math/tex">n</script> cols, + <script type="math/tex">n</script> cols, each of which affects <script type="math/tex">n</script> rows, summing to <script type="math/tex">2n^2</script> operations
                </p>
            </details>
			
			<h2><a target="_blank" href="https://codeforces.com/gym/516050/problem/F">Problem 10 - Rigging Revolver Rounds</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">
// written by Chongtian Ma 

#include &lt;bits/stdc++.h&gt;
using namespace std;

using ll = long long;
const int MOD = 1e9 + 7;
#define all(x) x.begin(), x.end()

// returns a vector of length n, smallest prime that it can be divided by
// runs in O(nloglogn) time.
vector&lt;int&gt; primesieve(int n) {
    vector&lt;int&gt; sieve(n);
    iota(sieve.begin(), sieve.end(), 0);
    for (int i = 2; i &lt; n; i++)
        if (sieve[i] == i)
            for (int j = 2*i; j &lt; n; j += i)
                sieve[j] = min(sieve[j], i);
    return sieve;
}

// only works for numbers &lt;= sieve len
vector&lt;int&gt; primefactors(int x){
	static auto sieve = primesieve(2e5 + 5);
	vector&lt;int&gt; ret;
	while(x &gt; 1){
		int cur = sieve[x];
		while(x % cur == 0){
			 x /= cur;
			 ret.push_back(cur); 
		}
	}
	return ret;
}

ll modpow(ll a, ll b, ll m){
	ll res = 1;
	while(b){
		if(b & 1) res = (res * a) % m;
		a = (a * a) % m;
		b /= 2;
	}
	return res;
}


void solve(){
	int n; cin &gt;&gt; n;
	vector&lt;int&gt; P(n);
	for(int& i: P){
		cin &gt;&gt; i;
		--i;
	}
	vector&lt;bool&gt; vis(n);
	vector&lt;pair&lt;int, int&gt;&gt; cycles;
	map&lt;int, int&gt; mp;
	for(int i = 0; i &lt; n; i++){
		if(!vis[i]){
			int cyc_len = 0;
			int j = i;
			while(!vis[j]){
				cyc_len++;
				vis[j] = 1;
				j = P[j];
			}
			if(mp[cyc_len] &lt; 2){
				cycles.push_back({cyc_len, i});
				mp[cyc_len]++;
			}
			
		}
	}
	
	int m = cycles.size();
	vector&lt;vector&lt;int&gt;&gt; prime_factors(n + 1);
	for(int i = 1; i &lt;= n; i++){
		prime_factors[i] = primefactors(i);
	}
	vector&lt;multiset&lt;int&gt;&gt; prime_factor_ms(n + 1);
	
	set&lt;int&gt; prime_matter;
	
	array&lt;ll, 3&gt; ans = {-1, -1, -1};
	
	auto re_eval = [&](vector&lt;int&gt; sus, int i, int j) -&gt; void{
		vector&lt;int&gt; new_added_p;
		for(int su : sus) {
			map&lt;int, int&gt; cnt;
			for(int l: prime_factors[su]){
				cnt[l]++;
			}
			for(auto [p, v] : cnt){
				auto& s = prime_factor_ms[p];
				s.insert(v);
				if(prime_matter.insert(p).second){
					new_added_p.push_back(p);
				}
		    }
	    }
	    
	    ll _lcm = 1;
	    for(int k: prime_matter){
	    	if(prime_factor_ms[k].size() &gt; 0){
	    		_lcm *= modpow(k, *prev(prime_factor_ms[k].end()), MOD);
	    		_lcm %= MOD;
	    	}
	    }
		ans = max(ans, {_lcm, i, j});
	    for(int su : sus) {
			map&lt;int, int&gt; cnt;
			for(int l: prime_factors[su]){
				cnt[l]++;
			}
		     for(auto [p, v] : cnt){
		    	auto& s = prime_factor_ms[p];
				s.erase(s.find(v));
		    }
	    }
	    for(int i: new_added_p){
	    	prime_matter.erase(i);
	    }
	};
	
	auto remove = [&](int k){
		map&lt;int, int&gt; cnt;
		for(int l: prime_factors[k]){
			cnt[l]++;
		}
		for(auto [p, v] : cnt){
			auto& s = prime_factor_ms[p];
			if(s.count(v)){
				s.erase(s.find(v));
			}
		}
	};
	
	auto readd = [&](int k){
		map&lt;int, int&gt; cnt;
		for(int l: prime_factors[k]){
			cnt[l]++;
		}
		for(auto [p, v] : cnt){
			prime_matter.insert(p);
			auto& s = prime_factor_ms[p];
			s.insert(v);
		}
	};
	
	for(int i = 0; i &lt; m; i++){
		readd(cycles[i].first);
	}
	
	for(int i = 0; i &lt; m; i++){
		for(int j = i + 1; j &lt; m; j++){
			// combine these two cycles
			for(int k: {cycles[i].first, cycles[j].first}){
				remove(k);
			}
			int su = cycles[i].first + cycles[j].first;
			re_eval({su}, cycles[i].second, cycles[j].second);
		    
		    for(int k: {cycles[i].first, cycles[j].first}){
				readd(k);
			}
		}
	}
	
	for(int i = 0; i &lt; m; i++){
		int cur = cycles[i].second;
		int cyc_len = cycles[i].first;
		remove(cyc_len);
		
		for(int j = 1; j &lt; cyc_len; j++){
			cur = P[cur];
			re_eval({j, cyc_len - j}, cycles[i].second, cur);
		}
		readd(cyc_len);
	}
	
	cout &lt;&lt; ans[0] &lt;&lt; " " &lt;&lt; ans[1] + 1 &lt;&lt; " " &lt;&lt; ans[2] + 1 &lt;&lt; "\n";
}


int main(){
	cin.tie(0) -&gt; sync_with_stdio(0);
	int t = 1;
	cin &gt;&gt; t;
	while(t--){
		solve();
	}
}

                </code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
                <span style="white-space: pre-line"><p>
                    There are a lot to consider for this problem. First, let's consider the answer if we can perform no operations. We can model the problem is a graph where there is an edge from every <script type="math/tex">i</script> to <script type="math/tex">p_i</script>. Since there are <script type="math/tex">n</script> edges and <script type="math/tex">n</script> vertices, this graph can be decomposed into a functional graph. Since all <script type="math/tex">p_i</script> are guaranteed distinct, we are guaranteed that every vertex <script type="math/tex">i</script> is part of distinct cycle. So essentially, you are given a graph with a bunch of non-intersecting cycles. 

Next, we can see that the answer to the problem is the least common multiple (lcm) of all cycle lengths. Why? For each cycle, if its length is <script type="math/tex">c_i</script>, you will need to fire exactly <script type="math/tex">c_i</script> rounds for it to end up at the chamber you started at. Since you want this to apply to all cycles, the least number of times you can ensure this is its lcm.

We can rephrase the questions as the following: Given <script type="math/tex">c_1, c_2, ... c_m</script> where <script type="math/tex">m</script> is the number of cycles, we want to find lcm(<script type="math/tex">c_1, c_2, ... c_m</script>). Now, we can consider the operations.

The operation swap exactly two edges in the graph. From this, we have two cases: Swap two edges that are not in the same cycle or two edges in the same cycle. The first case essentially merges two cycles together (performing this operation on cycles <script type="math/tex">i</script> and <script type="math/tex">j</script> creates a new cycle <script type="math/tex">k</script> such that <script type="math/tex">c_k = c_i + c_j</script>. What this does to array <script type="math/tex">c</script> is the following: erase <script type="math/tex">c_i</script> and <script type="math/tex">c_j</script> from <script type="math/tex">c</script> and insert <script type="math/tex">c_k</script>, and recompute the lcm and take the max of all such possible merges. However, if we were to loop through all cycles <script type="math/tex">i</script> and <script type="math/tex">j</script>, then our algorithm will take worst case <script type="math/tex">\mathcal{O}(n^2)</script> time, which is bad. This is where a clever optimization from a common technique comes in.

It can be shown that if we have an array of numbers <script type="math/tex">a_1, a_2, ... </script> that sum up to <script type="math/tex">s</script>, then there can be at most <script type="math/tex">\sqrt{s}</script> distinct numbers among array <script type="math/tex">a</script>. Why? consider the worst case, that is, if <script type="math/tex">a</script> consisted of <script type="math/tex">1, 2, 3, ..., k</script>. Since the sum of these natural numbers is <script type="math/tex">\frac{k \cdot (k + 1)}{2} = s</script>, we get that <script type="math/tex">k</script> must be approximately <script type="math/tex">\sqrt{s}</script>. 

Let's apply this idea to array <script type="math/tex">c</script>. We know that <script type="math/tex">c_1 + c_2 + ... + c_m = n</script>, since there are <script type="math/tex">n</script> total vertices. This means that there can be at most <script type="math/tex">\sqrt{n}</script> distinct numbers among <script type="math/tex">c</script>. Since merging the same <script type="math/tex">c_i</script> and <script type="math/tex">c_j</script> multiple times does not affect our answer (since we are taking lcm of the same number), we only have to track a certain number of each distinct <script type="math/tex">c_i</script>. It can be proven that we need to track at most <script type="math/tex">2</script> of each distinct <script type="math/tex">c_i</script>!. This is because, in the worst case, we can still merge <script type="math/tex">c_i</script> and <script type="math/tex">c_j</script> if <script type="math/tex">c_i = c_j</script>.

Let's prune <script type="math/tex">c_i</script> of numbers where there are more than <script type="math/tex">2</script> duplicates (or you can do this when you originally construct <script type="math/tex">c</script>). We have guaranteed that <script type="math/tex">m</script> is approximately at most <script type="math/tex">\sqrt{n}</script>. Now, when we run our previous <script type="math/tex">\mathcal{O}(m^2)</script> algorithm, this will take at most <script type="math/tex">\mathcal{O}(m^2 = n)</script> time!

Let's now focus on the second case: where we swap two edges from the same cycle. This essentially breaks the cycle apart into two pieces of lengths <script type="math/tex">a</script> and <script type="math/tex">c_i - a</script>. This is possible if we pick two vertices <script type="math/tex">x</script> and <script type="math/tex">y</script> from the same cycle and <script type="math/tex">y</script> is <script type="math/tex">a</script> vertices away from <script type="math/tex">x</script>, and swap their edges. Rephrasing the operation in terms of our version of the problem, this operation does the following: erase <script type="math/tex">c_i</script> from <script type="math/tex">c</script>, and insert <script type="math/tex">a</script> and <script type="math/tex">c_i - a</script> into <script type="math/tex">c</script>. We can focus on one cycle at at time, fix the first vertex in the cycle in which we will do the operation on (it does not matter what vertex), and loop through all other vertices in the cycle. This will take <script type="math/tex">\mathcal{O}(n)</script> time. 

Now, all that's left is to efficiently calculate the lcm! Obviously, we can't take <script type="math/tex">lcm(c_1, c_2,  ... , c_m)</script> naively becuase the lcm can large enough to 64-bit integer overflow. We have to resort to breaking down the lcm function. It is a common technique in number theory that, taking the lcm of an array of numbers is equivalent to multiplying the largest powers of the union of prime factors that make up each number in the array (for a more detailed explanation, refer to <a href="https://math.libretexts.org/Bookshelves/PreAlgebra/Prealgebra_1e_(OpenStax)/02%3A_Introduction_to_the_Language_of_Algebra/2.10%3A_Prime_Factorization_and_the_Least_Common_Multiple_(Part_2)">this article</a>). This means that in our algorithm, we needs to keep track of the prime factors that make up each <script type="math/tex">c_i</script> and the maximum power of each prime factor. Let's denote an array of distinct prime factors as <script type="math/tex">p_1, p_2, ..., p_k</script>. Note that <script type="math/tex">k</script> is at most <script type="math/tex">\log(n)</script>, since each <script type="math/tex">c_i</script> is bounded by <script type="math/tex">n</script>. To keep track of the maximum power for each <script type="math/tex">p_i</script>, we can track all possible powers in a multiset. 

Thus, for this problem, it is necessary to create a data structure that needs to efficently track <script type="math/tex">p</script> from <script type="math/tex">c</script> and can efficiently do the following:
	- Insert a number <script type="math/tex">x</script>. When <script type="math/tex">x</script> is inserted, it should be immediately broken down to its prime factorization. We then have to loop through all the prime factors and insert its power into the multiset for that prime.
	- Remove a number <script type="math/tex">x</script>. When <script type="math/tex">x</script> is removed, it also should be prime factorized, and its prime powers are erased from its respective multisets.
	- Efficiently re-evaluate the lcm of all prime factors present in <script type="math/tex">p</script>, taken mod <script type="math/tex">10^9+7</script>. This should loop through all elements of <script type="math/tex">p</script> and compute <script type="math/tex">p_1^{m_1} \cdot p_2^{m_2} \cdot ... \cdot p_k^{m_k}</script> where <script type="math/tex">m_i</script> is the largest power for prime <script type="math/tex">p_i</script>.

The rest is left up to implementation details. A number can be efficiently prime factorized if we precompute Sieve of Eratosthenes beforehand in <script type="math/tex">\mathcal{O}(n \log^2 n)</script> time and track the largest prime that divides each number from <script type="math/tex">1, 2, 3, ..., n</script>. Since a number can have at most <script type="math/tex">\log(n) </script> prime factors, prime factorizing each number will take at most <script type="math/tex">\log(n)</script> time. 

Putting everything together, the final complexity should be around <script type="math/tex">\mathcal{O}(n \log^2 n)</script> time from the Sieve of Eratosthenes and when we insert each prime power into its respective multiset.
                </p>
            </details>


            <h2><a target="_blank" href="https://codeforces.com/gym/516050/problem/G">Problem 11 - Scary Sagging Stalactites</a></h2>
            <details>
                <summary>Solution</summary>
                <pre><code class="language-cpp">//written by Matthew Chen
#pragma region
#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
#define int ll
using pii = pair&lt;int,int&gt;;
#define vt vector
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
#define debug(...)
#endif
#define fi first
#define se second
#define pb push_back 
#define lb lower_bound
#define ub upper_bound
#define sz(x) (int)(x).size()
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define YES cout &lt;&lt; "YES" &lt;&lt; '\n'
#define NO cout &lt;&lt; "NO" &lt;&lt; '\n'
#define IMP cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; '\n'
#define FOR(i,s,e) for (int i = (s); i &lt; (e); ++i) 
#define F0R(i,e) FOR(i,0,e) 
#define ROF(i,s,e) for (int i = (e)-1; i &gt;= (s); --i) 
#define R0F(i,e) ROF(i,0,e) 
#define printv(v,s,e) FOR(i,s,e+1) cout &lt;&lt; v[i] &lt;&lt; ' '; cout &lt;&lt; '\n'
#define ir(...) int __VA_ARGS__; re(__VA_ARGS__);
template&lt;class T&gt; using min_priority_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;
template&lt;class T, class H&gt; istream& operator&gt;&gt;(istream& in, pair&lt;H, T&gt;& a) {in &gt;&gt; a.fi &gt;&gt; a.se; return in;};
template&lt;typename T&gt; istream& operator&gt;&gt;(istream& in, vector&lt;T&gt;& a) {for(auto &x: a) in &gt;&gt; x; return in;};
template&lt;class T&gt; void re(T &x) {cin &gt;&gt; x;}
template&lt;class H, class... T&gt; void re(H &h, T &...t) { re(h); re(t...); }
#pragma endregion

const int N = 1E5+10;
vt&lt;int&gt; adj[N];
void func(map&lt;int,vt&lt;int&gt;&gt;& mp, vt&lt;array&lt;int,4&gt;&gt;& stor, int typ) {
    for (auto [key,val]: mp) {
        vt&lt;array&lt;int,3&gt;&gt; v;
        for (int i: val) {
            if (typ == 0) v.pb({stor[i][1],stor[i][3]+1,i});
            else v.pb({stor[i][0],stor[i][2]+1,i});
        }
        sort(all(v));//sorted by left
        for (auto [l,r,i]: v) {
            auto a = lb(all(v), array&lt;int,3&gt;{l,0,0});
            auto b = lb(all(v), array&lt;int,3&gt;{r,(int)2e9,(int)2e9});//?
            for (auto it = a; it != b && it != v.end(); it++) {
                if (i != (*it)[2]) {
                    adj[i].pb((*it)[2]);
                    adj[(*it)[2]].pb(i);
                }
            }
        }
        v.clear();
        for (int i: val) {
            if (typ == 0) v.pb({stor[i][3]+1,stor[i][1],i});
            else v.pb({stor[i][2]+1,stor[i][0],i});
        }
        sort(all(v));//sorted by right
        for (auto [r,l,i]: v) {
            auto a = lb(all(v), array&lt;int,3&gt;{l,0,0});
            auto b = lb(all(v), array&lt;int,3&gt;{r,(int)2E9,(int)2E9});//?
            for (auto it = a; it != b && it != v.end(); it++) {
                if (i != (*it)[2]) {
                    adj[i].pb((*it)[2]);
                    adj[(*it)[2]].pb(i);
                }
            }
        }
    }
}
void solve() {
    ir(n,m,k);
    vt&lt;array&lt;int,4&gt;&gt; stor(k);
    F0R(i,k) {
        ir(a,b,c,d);
        stor[i] = {a,b,c,d};
    }
    map&lt;int, vt&lt;int&gt;&gt; x, y;
    F0R(i,k) {
        x[stor[i][0]].pb(i);
        x[stor[i][2]+1].pb(i);
        y[stor[i][1]].pb(i);
        y[stor[i][3]+1].pb(i);
    }
    
    func(x, stor, 0);
    func(y, stor, 1);
    
    //multi bfs
    queue&lt;int&gt; q;
    vt&lt;bool&gt; vis(k,0);
    vt&lt;pii&gt; pa_dist(k, {-1,0});
    F0R(i,k) {
        auto [bx, by, tx, ty] = stor[i];
        if (bx == 0 || ty == m-1) {
            q.push(i);
            vis[i] = 1;
            pa_dist[i] = {-1,0};
        }
    }
    while (sz(q)) {
        int v = q.front();
        q.pop();
        for (int i: adj[v]) if (!vis[i]) {
            vis[i] = 1;
            q.push(i);
            pa_dist[i].fi = v;
            pa_dist[i].se = pa_dist[v].se+1;
        }
    }
    int mn = -1;
    F0R(i,k) {
        auto [bx, by, tx, ty] = stor[i];
        if (vis[i] && (tx == n-1 || by == 0)) {
            if (mn == -1 || pa_dist[mn].se &gt; pa_dist[i].se) {
                mn = i;
            }
        }
    }
    if (mn == -1) {
        cout &lt;&lt; -1 &lt;&lt; '\n';
        return;
    }
    vt&lt;int&gt; ans = {mn};
    while (pa_dist[mn].fi != -1) {
        mn = pa_dist[mn].fi;
        ans.pb(mn);
    }
    cout &lt;&lt; sz(ans) &lt;&lt; ' ';
    for (int i: ans) cout &lt;&lt; i+1 &lt;&lt; ' ';
}
signed main() {
    #ifdef LOCAL
    freopen("txt.in","r",stdin);
    freopen("txt.out","w",stdout);
    #else
    ios_base::sync_with_stdio(0); cin.tie(0);
    #endif
    int t = 1;
    //cin &gt;&gt; t;
    while (t--) {
        solve();
    }
}
                </code></pre>
            </details>
            <br>
            <details>
                <summary>Explanation</summary>
                <span style="white-space: pre-line"><p>
                    In essence, we want to choose a set of rectangles such that we can't go from (0,0) to (n-1,m-1)

A useful visualization is turning the set of rectangles a graph. Each rectangle becomes a node and two nodes are connected if their corresponding rectangles share a border (even including just a corner).

Let's label any node with a rectangle that shares a border to the top or left borders of the grid as our "start" nodes. Likewise, label any node with a rectangle that shares a border to the bottom or right borders as "end" nodes.

The problem boils down to finding a path from a "start" to "end" node with minimum length. This can be easily done through a multi-source BFS.

BFS from all the start nodes, then iterate through each "end" node and find the one with minimum distance from the start nodes. Keep in mind that u have to maintain both a distance array and a parent array. The problem also asks for a valid set of rectangles that satisfies the requirement, so we have to find all the nodes on that path.

Now the question is, how do we generate the edges between the nodes?

First, iterate through each distinct x/y value, and find the set, S, of all rectangles that share a border to that same x/y value. This can be done through a <code>map<int,vector<int>></code> where the key is the x/y value, and the value is a vector of indices of the rectangles (which we will also use as our node labelling).

Convert each rectangle in S to just [y1,y2] borders of the opposite dimension. For example, if we had rectangles that share a border to x = 5, then look at their corresponding y bounds.
Two rectangles share an x border/corner if there is an intersection of their [y1,y2].

This problem further boils down to finding intersecting intervals per each distinct x and y value.
This can be easily done with binary search for each interval to find other intervals with a left/right border within the current interval.
Then, manually iterate through them to generate edges.

After, just follow the strategy of BFS and minimizing the path.
A proof to the bounds of the graph and time complexity is left as an exercise to the reader.
                </p>
            </details>
			
			<h2><a target="_blank" href="https://codeforces.com/gym/516050/problem/H">Problem 12 - Bye Bye! We out! - MAKING HAM KEK</a></h2>
            <details>
                <summary>Rough Solution Sketch</summary>
                <span style="white-space: pre-line"><p>
                    (written by Chongtian Ma, idea contributed by Patrick Deng)
					
					We can find all the vertices which are not included in the answer (let's call them bad). A vertex is bad if it can reach another vertex using the edges of the graph that is not included in the tree. In other words, if an edge in the graph provides a "shortcut" compared to the edges in the tree to another vertex, then it is bad. Let dist(<script type="math/tex">u</script>, <script type="math/tex">v</script>) denote the sum of weights from the path from vertices <script type="math/tex">u</script> to <script type="math/tex">v</script> in the tree. For each edge <script type="math/tex">(u, v, w)</script> in the graph, if <script type="math/tex">w < dist(u, v)</script>, then we need to process this edge.
					
					To process each of these shortcut edges, we need to find all the vertices they affect. Note that the property of a tree is so that there is at most one path between every pair of vertices. Let's consider the following cases:
					
					1. The affected node is on the path from <script type="math/tex">u</script> to <script type="math/tex">v</script>. We can binary search for these vertices from <script type="math/tex">u</script> to <script type="math/tex">v</script>. For instance, vertex <script type="math/tex">s</script> is bad if <script type="math/tex">dist(u, s) + w < dist(s, v)</script> or <script type="math/tex">dist(s, v) + w < dist(u, s)</script>. Let's denote two vertices as <script type="math/tex">x</script> and <script type="math/tex">y</script> if the vertices on the path from <script type="math/tex">u</script> to <script type="math/tex">x</script> are all bad and the vertices on the path from <script type="math/tex">v</script> to <script type="math/tex">y</script> are bad.
					
					2. Let's denote a "hanging tree" off a node <script type="math/tex">k</script> on the path from <script type="math/tex">u</script> to <script type="math/tex">v</script> as a subtree rooted at <script type="math/tex">k</script> and no node in the subtree are on the path from <script type="math/tex">u</script> to <script type="math/tex">v</script>. All vertices in hanging trees rooted at any vertex from the path from <script type="math/tex">u</script> to <script type="math/tex">x</script> or the path from <script type="math/tex">v</script> to <script type="math/tex">y</script> should be marked as bad.

					We can efficiently calculate the dist function using generic binary lifting. We can mark each hanging tree using prefix-sums, then apply to each node in the subtree through post-processing. Note that the implementation is relatively unpleasant, as there are several cases to consider with LCA (least common ancestor) problems like these (for example, if <script type="math/tex">u</script> is already an ancestor of <script type="math/tex">y</script> or vice versa).
					
					The answer is all of the unmarked vertices.
                </p>
            </details>
        </fieldset>
    </div>
</body>
