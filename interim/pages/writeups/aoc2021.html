<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../../templates/template.css" type="text/css">
    <link rel="icon" href="../../templates/favicon.ico">
    <script src="../../templates/template.js"></script>

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../templates/gruvbox-dark-pale.min.css">
    <script src="../../templates/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>StuyCCC</title>
</head>
<body>
    <div id="side"></div>
    <div id="main">
        <h4>Last Updated 2021-12-18</h4>
        <fieldset>
            <legend>ADVENT OF CODE 2021</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <h2><a href="https://adventofcode.com/2021/day/1">Problem 01</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [int(line.strip()) for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    cnt = 0;
    for i in range(1, len(lines)):
        if (lines[i] &gt; lines[i-1]):
            cnt += 1;
    return cnt;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Well this first problem doesn't really need much explanation, just figure out how to read input from a file for your respective language. And then loop through the list you have gotten and if i != 0 and list[i] &gt; list[i-1] increment the count. And at the end print the count.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [int(line.strip()) for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    cnt = 0;
    for i in range (3, len(lines)):
        if (lines[i] &gt; lines[i-3]):
            cnt += 1;
    return cnt;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Notice that when you are comparing two sets of three in for example the list [a,b,c,d] if we compare a+b+c and b+c+d we really are only comparing between a and d. So for this part we can just loop through the list and if i &gt;= 3 and list[i] &gt; list[i-3] increment the count, and at the end print the count.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/2">Problem 02</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip().split() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    x,y = 0,0;
    for i in range(len(lines)):
        if (lines[i][0] == "forward"): x += int(lines[i][1]);
        if (lines[i][0] == "down"): y += int(lines[i][1]);
        if (lines[i][0] == "up"): y -= int(lines[i][1]);
    return x*y;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>The instructions for this problem is fairly simple, First read in the lines from the input file. Then initialize x and y to 0. Then for each line in the lines read, split them by the space and then if 1st part is "forward" increase x by the 2nd part, if 1st part is "down" increase y by the 2nd part, and if 1st part is "up" decrease y by the 2nd part. Finally at the end print x*y.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip().split() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    x,y,a = 0,0,0;
    for i in range(len(lines)):
        if (lines[i][0] == "forward"):
            x += int(lines[i][1]);
            y += a * int(lines[i][1]);
        if (lines[i][0] == "down"): a += int(lines[i][1]);
        if (lines[i][0] == "up"): a -= int(lines[i][1]);
    return x*y;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>The instructions for this problem is fairly simple as well. First read in the lines from the input file. Then initialize x, y, and a to 0. Then for each line in the lines read, split them by the space and then if the 1st part is "forward" increase x by the 2nd part and increase y by a * 2nd part, if the 1st part is "down" decrease a by the 2nd part, and if the 1st part is "up" increase a by the 2nd part. Finally at the end print x*y.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/3">Problem 03</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    gamma = "";
    epsilon = "";
    lt = [0] * len(lines[0]);
    for line in lines:
        for i,x in enumerate(line):
            if (x == "1"): lt[i] += 1;
    for x in lt:
        if (x &gt; len(lines)-x):
            gamma += "1";
            epsilon += "0";
        else:
            gamma += "0";
            epsilon += "1";
    return int(gamma, 2) * int(epsilon, 2);

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>First initialize two empty strings gamma and epsilon. For each position (from left to right) in the bit strings read, loop through the entire list keeping track of the number of 1s found in that certain position, lets call this number x. If x &gt; len(lines) - x append a 1 to gamma and append a 0 to epsilon, else append a 0 to gamma and append a 1 to epsilon. After gamma and epsilon are the same size at the original bit strings convert them into integers and then multiple them, and return the answer.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    cpy1 = [x for x in lines];
    cpy2 = [x for x in lines];
    for i in range(len(lines[0])):
        cnt = 0;
        for x in cpy1:
            if (x[i] == "1"): cnt += 1;
        if (cnt &gt;= len(cpy1)-cnt): rem = "0";
        else: rem = "1";
        cpy1 = [x for x in cpy1 if x[i] != rem];
        if (len(cpy1) == 1): break;
    for i in range(len(lines[0])):
        cnt = 0;
        for x in cpy2:
            if (x[i] == "1"): cnt += 1;
        if (cnt &gt;= len(cpy2)-cnt): rem = "1";
        else: rem = "0";
        cpy2 = [x for x in cpy2 if x[i] != rem];
        if (len(cpy2) == 1): break;
    return int(cpy1[0], 2) * int(cpy2[0], 2);

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Again first initialize two copies of the list of lines read. Then for the first cpy loop through each bit position, i, and count the number of 1s, lets call it x. If x &gt;= len(cpy1)-x loop set a char rem = '0' else rem = '1'. Loop through cpy1 again and remove all strings that have an ith bit that is not equal to rem. At the end of replacing if len(cpy1) == 1 break out of the loop. Do the same thing for cpy2 except switch the values for rem in the conditions. Finally convert the last elements in both copies to integers and print their multiple.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/4">Problem 04</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n\n")];
    lines = [[[int(x) for x in row.split()] for row in line.split("\n")] if i != 0 else [int(x) for x in line.split(",")] for i,line in enumerate(lines)];
    fout.write(str(solve(lines)));

def add(board, num):
    for i in range(5):
        for q in range(5):
            if (board[i][q] == num):
                board[i][q] = -1;
                break;
    return board;

def check(board):
    for i in range(5):
        good1,good2 = True,True;
        for q in range(5):
            if (board[i][q] != -1): good1 = False;
            if (board[q][i] != -1): good2 = False;
        if (good1 == True or good2 == True): return True;
    return False;

def sum(board):
    sum = 0;
    for i in range(5):
        for q in range(5):
            if (board[i][q] != -1): sum += board[i][q];
    return sum;

def solve(lines):
    for x in lines[0]:
        for board in lines[1:]:
            board = add(board, x);
            if (check(board)):
                return sum(board) * x;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Some helpful things to do before we start, first notice that all the numbers given are positive so we can represent them as being reached by setting them to an impossible value like -1. Now create a check function that checks if in a given board if it completed (i.e. there are 5 -1's in a row or a column) and returns true if the board is completed. Also create an add function that goes through a board and looks for a certain number x, if that number is found it replaces it with -1 (ie saying that position has been found) and returns the board. Finally create a function that given a board sums all the values that aren't -1 (ie adding all numbers that aren't marked in a board).</p>
                <p>Now we have those helpful functions we can loop through the list of numbers in the order they are given and then loop through the boards using the add function to affect them. Directly after adding a number, check if the board is completed. If it is this means this board is the first one to be completed so we can just sum the remaining elements using sum and multiply it by the current number in the list of numbers and return the value (this ends the function and prevents double counting).</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n\n")];
    lines = [[[int(x) for x in row.split()] for row in line.split("\n")] if i != 0 else [int(x) for x in line.split(",")] for i,line in enumerate(lines)];
    fout.write(str(solve(lines)));

def add(board, num):
    for i in range(5):
        for q in range(5):
            if (board[i][q] == num):
                board[i][q] = -1;
                break;
    return board;

def check(board):
    for i in range(5):
        good1,good2 = True,True;
        for q in range(5):
            if (board[i][q] != -1): good1 = False;
            if (board[q][i] != -1): good2 = False;
        if (good1 == True or good2 == True): return True;
    return False;

def sum(board):
    sum = 0;
    for i in range(5):
        for q in range(5):
            if (board[i][q] != -1): sum += board[i][q];
    return sum;

def solve(lines):
    bad = set();
    for x in lines[0]:
        for i,board in enumerate(lines[1:]):
            board = add(board, x);
            if (check(board)):
                bad.add(i);
            if (len(bad) == len(lines)-1):
                return sum(board) * x;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>We are going to use the same helper functions as described in part 1, but our algorithm changes a bit. First initialize a set called "bad" which represents all the completed boards. We are first looping through the list of numbers given in order, and then loop through the boards like in part 1. Also add to the boards we loop through as well and check them, however this time if the check turns out to be true instead of ending the function we are going to add the index value of the board into the bad set. We are going to continue this process until the bad set reaches the same size as the number of boards given. Notice that the set is used to prevent overcounting of bad sets. Now when we see that the bad set is equal in size to the number of boards that means the board that just added to the bad set is the last board, so we can return the sum of this board times the current number.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/5">Problem 05</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-cpp">
// Written by Maxwell Zen
#include&lt;bits/stdc++.h&gt;
using namespace std;

int cnt[1000][1000];

// return direction a must go to meet b
int dir(int a, int b) {
    if (a&lt;b) return 1;
    else if (a==b) return 0;
    return -1;
}

int main() {
    ifstream fin ("input.txt");
    string s;
    // read each line into a string s;
    while ( getline (fin, s) ) {
        int x, y, x2, y2;
        // scan coordinates from string
        sscanf(s.c_str(), "%d,%d -&gt; %d,%d", &x, &y, &x2, &y2);
        int dx = dir(x, x2), dy = dir(y, y2);
        while (true) {
            // increment only if line is horizontal or vertical
            if (dx==0 || dy==0) cnt[x][y]++;
            // break if we've reached endpoint
            if (x==x2 && y==y2) break;
            // step forward
            x += dx; y += dy;
        }
    }
    int ans = 0;
    // count points counted more than once
    for (int i = 0; i &lt; 1000; i++) {
        for (int j = 0; j &lt; 1000; j++) {
            if (cnt[i][j]&gt;1) ans++;
        }
    }
    // output answer
    cout &lt;&lt; ans &lt;&lt; endl;
}
            </code></pre>
            <h3>Explanation</h3>
            <p>First create a 2d array of ints called cnt to store how many times a point is marked by a line. We'll start with x and y at the initial coordinates of the line, and set dx and dy to the direction x and y must move in (1, 0, or -1). To calculate dx and dy, we write a function dir that returns 1, 0, or -1, depending on which direction the first argument must move in to meet the second argument. Then in a while loop, we increment cnt if the line is horizontal or vertical (dx is 0 or dy is 0). If we've reached the endpoint, we break out of the whiel loop, otherwise we keep going. Finally, we go through each point to count how many have been incremented more than once.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-cpp">
// Written by Maxwell Zen
#include&lt;bits/stdc++.h&gt;
using namespace std;

int cnt[1000][1000];

// return direction a must go to meet b
int dir(int a, int b) {
    if (a&lt;b) return 1;
    else if (a==b) return 0;
    return -1;
}

int main() {
    ifstream fin ("input.txt");
    string s;
    // read each line into a string s;
    while ( getline (fin, s) ) {
        int x, y, x2, y2;
        // scan coordinates from string
        sscanf(s.c_str(), "%d,%d -&gt; %d,%d", &x, &y, &x2, &y2);
        int dx = dir(x, x2), dy = dir(y, y2);
        while (true) {
            // increment count
            cnt[x][y]++;
            // break if we've reached endpoint
            if (x==x2 && y==y2) break;
            // step forward
            x += dx; y += dy;
        }
    }
    int ans = 0;
    // count points counted more than once
    for (int i = 0; i &lt; 1000; i++) {
        for (int j = 0; j &lt; 1000; j++) {
            if (cnt[i][j]&gt;1) ans++;
        }
    }
    // output answer
    cout &lt;&lt; ans &lt;&lt; endl;
}
                </code></pre>
                <h3>Explanation</h3>
                <p>This code is almost exactly the same as the previous part. The only difference is that diagonal lines are counted, so we increment cnt at each point regardless of whether the line is vertical or horizontal.</p>
                <p>For some more nice discussion on this problem, it is worth checking out <a href="https://cestlaz.github.io/post/advent-2021-day05/">this</a> blog post by former Stuyvesant teacher Mike Zamansky.</p>
            </details>

    <h2><a href="https://adventofcode.com/2021/day/6">Problem 06</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Written by Maxwell Zen
s = open("input.txt", 'r').read()
s = s.split(',')
a = [int(num) for num in s]
for day in range(80):
    b = []
    for i in a:
        if i == 0:
            b += [6, 8]
        else:
            b += [i-1]
    a = b
print(len(a))
            </code></pre>
            <h3>Explanation</h3>
            <p>In part 1, it's possible to simply brute force your way through the problem. We'll maintain a list of lanternfish, recording how many days each lanternfish has left to go. For each day, we create a new list out of the old one -- lanternfish at 0 days will split into a lanternfish at 6 days and a lanternfish at 8 days, and all other lanternfish will just have their value subtracted by 1. At the end, we return the length of the array as the number of lanternfish.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Written by Maxwell Zen
s = open("input.txt", 'r').read()
s = s.split(',')
a = [int(num) for num in s]
count = [a.count(i) for i in range(9)]
for day in range(256):
    nxt = [0]*9
    for i in range(8):
        nxt[i] = count[i+1]
    nxt[8] = count[0]
    nxt[6] += count[0]
    count = nxt
print(sum(count))
                </code></pre>
                <h3>Explanation</h3>
                <p>After 256 days, the answer will be huge, so it's impossible to brute force keeping track of every lanternfish. Here's the key observation: we can group all lanternfish that have a certain number of days remaining, because the number of days remaining is the only thing that actually matters. So we can keep an array count that records how many lanternfish there are for each number of remaining days. To simulate a day passing, we set the new counts for 0 to 7 days equal to the original counts for 1 to 8 days. Then, to simulate the lanternfish with 0 days left, we add the original count for 0 days to the new counts for 6 and 8 days. Doing this 256 times will yield the answer.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/7">Problem 07</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n")[0:-1]];
    lines = [int(x) for x in lines[0].split(",")];
    fout.write(str(solve(lines)));

def solve(lines):
    lines.sort();
    med = lines[len(lines)/2];
    ans = 0;
    for x in lines:
        ans += abs(x-med);
    return ans;

main();
            </code></pre>
            <h3>Explanation</h3>
            <p>The ideal method of reducing cost for part 1 is to choose the median number as our aligning position and then move everyone to this median number. Notice that if the list has an even number of elements we can use either one of the median numbers. We can get the median number by sorting the list and then list[size/2] is the median number. So for each element in the list find the difference in their position from the median number, and sum up all those differences and then return the sum.</p>
            <p>The proof to this being the optimal minimization has to do with the following somewhat intuitive idea. If you already chose a position x to be your meeting point, if you increase x by 1, all the distances of points below x increase by 1 and all distances above x decrease by 1. You can read more about it <a href="https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-ell-1-norm">here</a>.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n")[0:-1]];
    lines = [int(x) for x in lines[0].split(",")];
    fout.write(str(solve(lines)));

def solve(lines):
    avg = 0.0;
    for x in lines: avg += x;
    avg /= len(lines);
    below = int(avg);
    above = int(avg+1);
    cost1 = 0;
    cost2 = 0;
    for x in lines:
        cost1 += abs(x-below)*(abs(x-below)+1)/2;
        cost2 += abs(x-above)*(abs(x-above)+1)/2;
    return min(cost1,cost2);

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>The ideal method of reducing cost for part 2 is the choose (somewhere near) the average number as our aligning position. Within +- .5 of the average according to some smart people on reddit. Also notice that when calculating the cost we have to do dif*(dif+1)/2 as our cost instead of just dif. Return the minimum of the two sums and that is our final answer.</p>
                <p>The proof to this minimizing dif*(dif+1)/2 cost gets its basis around the problem of solving a similar minimizing dif^2 cost, which we already know the answer to be the average. You can check the <a href="https://www.reddit.com/r/adventofcode/comments/rar7ty/2021_day_7_solutions/">subreddit</a> or google yourself for more detialed proofs. </p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/8">Problem 08</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Written by Maxwell Zen
lines = open("input.txt", 'r').read().split('\n')
lengths = [2, 3, 4, 7]
ans = 0
for line in lines:
    a,b = line.split(" | ")
    for j in b.split():
        if len(j) in lengths:
            ans+=1
print(ans)
                </code></pre>
                <h3>Explanation</h3>
                <p>For this part, you don't need to figure out which combination of segments (letters) maps to some digit. Notice that even though the segments have been mixed up, the number of segments that make up a number stays constant. As 1, 4, 7, and 8 each are comprised of a unique number of segments, it is enough to simply count the number of strings on the right of the "|" whose length is 2, 4, 3, or 7 respectively.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Written by Maxwell Zen
# letters corresponding to each digit
codes = ["abcefg", "cf", "acdeg", "acdfg", "bcdf",
"abdfg", "abdefg", "acf", "abcdefg", "abcdfg"]

lines = open("input.txt", 'r').read().split('\n')
total = 0

# frequencies of characters in four and not in four
infour = {6:'b', 7:'d', 8:'c', 9:'f'}
notfour = {4:'e', 7:'g', 8:'a'}

for line in lines:
    digits, output = line.split(" | ")
    decode = {}

    # find word corresponding to four
    for word in digits.split():
        if len(word) == 4:
            four = word

    # decode each letter
    for letter in "abcdefg":
        frequency = digits.count(letter)
        if letter in four:
            decode[letter] = infour[frequency]
        else:
            decode[letter] = notfour[frequency]

    output = output.split()
    val = 0
    for word in output:
        # decode each letter, then sort the characters
        letters = (decode[letter] for letter in word)
        translated = ''.join(sorted(letters))
        # update the output value
        val *= 10
        val += codes.index(translated)
    total += val
print(total)
                </code></pre>
                <h3>Explanation</h3>
                <p>The challenge here is to decode the scrambled letters. One method is to bash through every possible permutation of the segments, finding a permutation that works and using it to decode the output value. However, there's an even cleaner solution. We can count the number of times each segment appears in the digits from 0 to 9 and try to find a pattern there. e appears 4 times, b appears 6 times, d and g both appear 7 times, a and c both appear 8 times, and f appears 9 times. So the letters corresponding to e, b, and f can be found right away. In order to figure out which letters correspond to d/g and a/c, we can look at the digit 4 (which we can find since it's the only one to have length 4). Since d and c are both in 4, but g and a aren't, we can use that information to distinguish between d/g and a/c, unscrambling the letters. Finally, use this information to decode the output value, and you're done.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/9">Problem 9</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/10">Problem 10</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/11">Problem 11</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/12">Problem 12</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/13">Problem 13</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/14">Problem 14</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/15">Problem 15</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/16">Problem 16</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/17">Problem 17</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/18">Problem 18</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/19">Problem 19</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# Will Be Here Soon
                </code></pre>
                <h3>Explanation</h3>
                <p>Will Be Here Soon</p>
            </details>
        </fieldset>
    </div>
</body>
