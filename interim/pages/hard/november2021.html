<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../../templates/template.css" type="text/css">
    <link rel="icon" href="../../templates/favicon.ico">
    <script src="../../templates/template.js"></script>

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../templates/gruvbox-dark-pale.min.css">
    <script src="../../templates/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>StuyCCC</title>
</head>
<body>
    <div id="side"></div>
    <div id="main">
        <h4>Last Updated 2022-05-01</h4>
        <fieldset>
            <legend>HARD NOVEMBER 2021</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <a target="_blank" href="https://codeforces.com/problemset/problem/1327/C">Problem 30</a>
            <details>
                <summary>Solution</summary>
                <p>Note that 2nm is a gigantic limit, so there a bunch of ways to simulate this problem, and I am just going to give one. First lets move all the pieces to the top left corner by doing n-1 U operations and m-1 L operations. Now we can just snake across the entire board in nm-1 operations. The total amount of operations is nm + n + m - 3, which is well under the limit and every cell is reached by every chip, so it is gauranteed to work. Now you just have to simulate it :)</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1548/A">Problem 29</a>
            <details>
                <summary>Solution</summary>
                <p>The key observation for this problem is to realize two things: that at the end of the process no two nobles will still be friends (this can be seen by the fact that in every friend group the weakest friend will be removed until there is only one left) and that if all of his friends are weaker than him a noble can not be killed (there is no one stronger than him to kill him).</p>
                <p>So this leads to the key idea that if all of a nobles friends are weaker than it will survive, else it will die. So for each noble we can count the number of people weaker than it and the number of people its friends with. If these numbers are equivalent it survives else it doesn't. For each of the first two queries you can just add or subtract to the original counts.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc206/tasks/abc206_e">Problem 28</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/abc206/editorial/2107">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/agc053/tasks/agc053_b">Problem 27</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/agc053/editorial/1067">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/arc122/tasks/arc122_c">Problem 26</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/arc122/editorial/2071">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc208/tasks/abc208_e">Problem 25</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/abc208/editorial/2216">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://adventofcode.com/2015/day/20">Problem 24</a>
            <details>
                <summary>Solution</summary>
                <img src="../../data/hard/november24.png" width="525" height="600">
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1519/D">Problem 23</a>
            <details>
                <summary>Solution</summary>
                <p>The naive approach of iterating over the left position of the reversed interval, l, and the right position of the reversed interval, r would take O(n^3) and this is too slow for this problem. The key observation is that we can use prefix sums and a unique way of iterating through intervals to reduce this to O(n^2).</p>
                <p>Let P[i] = prefix sum of the a_j * b_j for j in range of 0 to i-1 inclusive. Notice that now we can represent the sum of the products of the array with a reversed interval as P[n]-P[r+1]+P[l]+sum where sum is the sum of the products of the reversed interval.</p>
                <p>Now we are going to iterate over the center positions of the interval. So for i in range 0 to n exclusive, i is going to represent the center position of an interval. We are going to start off with an interval of either size 2 or size 3 so we can handle both even and odd intervals. So l = i-1, r = i+1 (size 3), or l = i-1, r = i (size 2), or l = i, r = i+1 (size 2).</p>
                <p>Notice that if increase our interval left by 1 (l--) and right by 1 (r++) our interval sum increases by A[l]*B[r] + A[r]*B[l]. Now for every interval centered at i that is within bounds we can use the equation in paragraph 2 to get the product, and our answer will be the maximum of all these products.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1096/C">Problem 22</a>
            <details>
                <summary>Solution</summary>
                <p>The key observation for this problem is to realize that the angle abc that we are looking for is an inscribed angle which means that it is 1/2 of a central angle. Since we have an n-gon the central angle for 1 side is 360/n, so the smallest amount we can increase our central angle by is 360/n everytime, or 180/n for our inscribed angle. This means that our inscribed angle ang is in the form 180k/n where k is between 1 and n-2. k has to be n-2 or less because we need at least two unused sides to form our inscribed, Look at above diagram for clarity.</p>
                <p>We have ang = 180k/n which is equivalent ang * n = 180 * k. Lets define g = gcd(ang, 180) we can divide both sides by g and get ang/g * n = 180/g * k. Since gcd(ang/g, 180/g) = 1, we can see that ang/g has to be a divisor of k and 180/g has to be a divisor of n. So we have to have k = x * ang/g and n = x * 180/g. Since we want to minimize n we want to make x as small as possible. So lets start off with x=1, we have k = ang/g and n = 180/g. We can realize that this always works and we can output 180/g as our answer, unless k = n-1 (this does not satsify k &lt;= n-2 for our earlier condition), in which case we have to make x = 2, and output 2*180/g as our answer.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/agc031/tasks/agc031_c">Problem 21</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/agc031/editorial">here</a>.</p>
            </details>
            <br>
            <a href="../writeups/pc2021f.html">Problem 20</a>
            <details>
                <summary>Solution</summary>
                <p>Today was the day of the PClassic contest so we didn't do a regular POTD. Instead, you can go check out the writeup linked above and try to solve some PClassic problems.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1550/C">Problem 19</a>
            <details>
                <summary>Solution</summary>
                <p>Notice that a triple of points a, b, c is only bad if one of them lies in the rectangle formed by the other two points. Without loss of generality lets assume a and c are the corners of the rectangle. If b is outside the rectangle of a,c then dist(a,b) + dist(b,c) &gt; dist(a,c), so this is a valid triple, but if b is inside dist(a,b) + dist(b,c) = dist(a,c), which makes it a bad triple.</p>
                <p>Now lets define the points as they are in the problem a = (x,i), b = (y,q), c = (z,r) where i, q, r are indices. We can see that if a bad situation were to occur that would mean that (x &lt;= y &lt;= z or x &gt;= y &gt;= z) and (i &lt;= j &lt;= k or i &gt;= j &gt;= k). However, notice that since i, j, k are indices we only need to look at the situation were i &lt; j &lt; k, because if we also looked at the situation where i &gt; j &gt; k, we would start overcounting.</p>
                <p>Now look at our first condition we can rephrase that as if there are 3 non-decreasing or 3 non-increasing numbers in order (not necessarily adjacent to each other) in a subarray, then the subarray is invalid because those numbers can form a bad triple. Now notice that because we want this condition to be true, we can limit our subarray size to 4. If there is a subarray of size 5 it is guaranteed to have 3 non-increasing or 3 non-decreasing (you can prove this yourself by bashing it out).</p>
                <p>So finally our problem reduces to checking all size 1, 2, 3, 4 subarrays in the original array, to see if they have a bad triple and if they don't add them to a count, and then at the end of the program print the count.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1237/C1">Problem 18</a>
            <details>
                <summary>Solution</summary>
                <p>Realize that n &lt;= 2000, which means that we can have up to an n^2 solution for this problem. I am going to give the n^2 solution I used, and then prove that it is right. The solution that I used, is that n/2 times in a row I choose an arbitrary point x that hasn't been removed, then I choose the closest point to x that hasn't been removed yet, lets call it y. I choose these two points to be the pair that I remove, and this pair always work.</p>
                <p>Now lets see why. y is the closest point to x and now they form a bounding box being the top right and bottom left corners respectively. If a point was to be found in the bounding box, then that point would be closer to x than y is (because y is the farthest point in the bounding box from x). However we know that there is no point closer to x than y because we defined y to be the closest point. So the bounded box is always empty and we can always remove this pair of points, and our strategy works out in the end.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/507/B">Problem 17</a>
            <details>
                <summary>Solution</summary>
                <p>Lets call the euclidean distance between the two centers d (ie sqrt((x2-x1)^2 + (y2-y1)^2)). Notice that the maximum distance you can shift the center of the circle by is 2*R per move (done by rotating the circle by 180 degrees from any pin position). So we can see that it is optimal to move as much as possible until we are within 2*R of the center we want to find. Now notice that when we are within 2*R distance and not already at the end point, we can shift to the new center in one move (shown in diagram below). So now we can see that our optimal strategy leads to an answer of ceil(d/(2*R)).</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1458/A">Problem 16</a>
            <details>
                <summary>Solution</summary>
                <p>This problem can be easily solved if we know some GCD rules. GCD(x-y,y) = GCD(x,y), and this logic works for all arguments, so GCD(x,y,z) = GCD(x-y,y,z). Now notice that the answer we are looking for is GCD(a1+bj, a2+bj, ..., an+bj). We can subtract a1+bj from each term but the first and see that this is equal to GCD(a1+bj, a2-a1, ..., an-a1). We can precalculate GCD(a2-a1, ..., an-a1) and call it G. Now we have that the answer to every query is GCD(a1+bj, G). Note that to get G we might have to use GCD(x, 0) = 0. Also note that if a1 is not the smallest element in the sequences this does not work because then you get the GCD of a negative number.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1167/C">Problem 15</a>
            <details>
                <summary>Solution</summary>
                <p>To solve this problem we can just use the strategy of connected components where once we have a graph set up, for every not visited yet we can start a dfs from the user and everything that user can connect to will belong to the same connected component, and if they are in a certain connected component they can share information to everyone in that connected component, so for each user you just have to take the size of the connected component the user is inside of.</p>
                <p>Now we that we have the strategy we actually have to start creating the graph. Notice that if we add a edge from everyone to everyone else in each of the m groups this has n^2 edges which is too slow (to visualize this consider the case of only 1 group containing all people). So a better strategy is just to connect only adjacent people in each group as this still represents the fact that all information can spread just in a bit longer matter (but length of spread doesn't matter, only amount does). This observation reduces the complexity from n^2 to sum of k_i for each k_i in the m groups. Now that we have the optimization and the strategy we can easily solve the problem.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc194/tasks/abc194_e">Problem 14</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/abc194/editorial/863">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="../writeups/pclassicfall2021">Problem 13</a>
            <details>
                <summary>Solution</summary>
                <p>For some reason, we didn't give a POTD today, so instead you can go check out our pclassic writeups for some cool problems.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1514/C">Problem 12</a>
            <details>
                <summary>Solution</summary>
                <p>The first observation of this problem is to notice that if we include a number x &lt; n such that gcd(x, n) != 1 then the prod wont be 1 mod N. To see this in action, imagine we have n = 9 and we include 3 in the product. Prod % 9, must be either be 0, 3, or 6 (ie a multiple of 3), and thus it will never be 1, and that is not what we want. So now we know we should only include numbers that have gcd(x, n) == 1. Lets call p the product of all numbers that have gcd(x, n) == 1 modulo n. If p == 1 we can just output all those numbers, however if p != 1, we can just remove the number p itself and output the rest of the numbers. </p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/329/B">Problem 11</a>
            <details>
                <summary>Solution</summary>
                <p>The optimal strategy for the user in this problem is to take the shortest path to the exit cell. This is because if you take a non-shortest path this gives the other trainers an extra move to try to get to you. Now notice that the optimal play for the trainers is to get to the exit cell before or at the same time as you. This is because if they can get to the exit cell, you are forced to battle them before you can leave.</p>
                <p>Notice that since you are taking the shortest path to the exit cell, only trainers that have a closer or the same length shortest path to the exit cell can battle you, while others can not. This is because if they can battle you on cell X on your route to the exit, this means they can reach cell X before or at the same time as you. And cell X is on the shortest path so they can take the shortest path from cell X and reach the exit cell before you.</p>
                <p>So now this problem boils down to checking if the shortest path to the exit of the trainers are shorter than or equal to your shortest path to the exit. If they are you have to battle them, and if they aren't you don't have to battle them. You can find the shortest path to the exit for each trainer and yourself by doing a single bfs starting at the exit cell. Once you are done with the bfs just compare distances and add up trainers and output your answer.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1538/F">Problem 10</a>
            <details>
                <summary>Solution</summary>
                <p>There are a ton of overly difficult ways to solve this problem using dp, binary search, and the such, but I am going to give the simplest solution I found here. The total number of changed digits is equal to the sum of changes in each place (ie, ones place, tens place, hundreds place). The amount of changes in the ones place is equal to R - L, you can figure this out pretty trivially. Now notice that the number of changes in the 10s place is equivalent to floor(R/10) - floor(L/10). This same pattern occurs for the rest of the places as well. So for each digit place x from 0 to 9 add to the sum floor(R/10^x) - floor(L/10^x), and output this for your answer.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1475/C">Problem 09</a>
            <details>
                <summary>Solution</summary>
                <p>This problem boils down to the following for each of the k couples in the input, find out how many other couples they can dance with, and sum all these up and then divide 2(to prevent a,b and b,a overcounting) and output them. Let freq1[a], freq2[b] be the number of times a shows up in the first sequence and the number of times b shows up in the second sequences.</p>
                <p>Notice that if our current pair is (a,b) then any pairs of the form (a,x) and (x,b) fail, the number of these failed equivalent to freq1[a] + freq[b] - 1, where the -1 exists to remove the double counting of the pair (a,b) itself (because obviously (a,b) cant dance with (a,b), they are just 1 couple not 2. but (a,b) is counted in both freq1[a] and freq2[b], so we need to remove 1 to prevent overcounting.</p>
                <p>Now we know freq1[a]+freq2[b]-1 fails which means k-(freq1[a]+freq2[b]-1) works, so our final answer is (the sum of k-(freq1[a]+freq2[b]-1)) divided by 2.</p>
            </details>
            <br>
            <a target="_blank" href="https://codeforces.com/problemset/problem/1095/C">Problem 08</a>
            <details>
                <summary>Solution</summary>
                <p>Notice that the minimum powers of 2 needed to create the number n, is the number of 1 bits in the binary representation of n, lets call this number x, and lets say we have all the powers of 2 represented by these 1 bits in a multiset S. If x &gt; k, then our answer is NO because we can't decrease the power of 2s that we need. If x == k, we can just return the powers of 2 in S. If x &lt; k, we need to do break up some powers of 2 into smaller powers of 2. Observe that breaking up a power of 2 increases the total count x by 1. So we can just take a value in the multiset, split it into 2 and put its components back into the set. We can do this until all values equal 1, ie there are n 1s. So this means if n &lt; k, it we output NO, else we output whatever we had in our multiset, after we split powers of 2, k-x times.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/agc040/tasks/agc040_c">Problem 07</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/agc040/editorial">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/arc116/tasks/arc116_d">Problem 06</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/arc116/editorial/1035">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc183/tasks/abc183_e">Problem 05</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/abc183/editorial/344">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc196/tasks/abc196_d">Problem 04</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://atcoder.jp/contests/abc196/editorial/954">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/arc098/tasks/arc098_b">Problem 03</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://img.atcoder.jp/arc098/editorial.pdf">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc149/tasks/abc149_e">Problem 02</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://img.atcoder.jp/abc149/editorial.pdf">here</a>.</p>
            </details>
            <br>
            <a target="_blank" href="https://atcoder.jp/contests/abc147/tasks/abc147_d">Problem 01</a>
            <details>
                <summary>Solution</summary>
                <p>The solution can be found <a target="_blank" href="https://img.atcoder.jp/abc147/editorial.pdf">here</a>.</p>
            </details>
        </fieldset>
    </div>
</body>
