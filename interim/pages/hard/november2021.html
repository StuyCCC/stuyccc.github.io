<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../../templates/template.css" type="text/css">
    <link rel="icon" href="../../templates/favicon.ico">
    <script src="../../templates/template.js"></script>

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../templates/gruvbox-dark-pale.min.css">
    <script src="../../templates/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>StuyCCC</title>
</head>
<body>
    <div id="side"></div>
    <div id="main">
        <h4>Last Updated 2021-11-21</h4>
        <fieldset>
            <legend>HARD NOVEMBER 2021</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <a href="../writeups/pc2021f.html">Problem 20</a>
            <details>
                <summary>Solution</summary>
                <p>Today was the day of the PClassic contest so we didn't do a regular POTD. Instead, you can go check out the writeup linked above and try to solve some PClassic problems.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1550/C">Problem 19</a>
            <details>
                <summary>Solution</summary>
                <p>Notice that a triple of points a, b, c is only bad if one of them lies in the rectangle formed by the other two points. Without loss of generality lets assume a and c are the corners of the rectangle. If b is outside the rectangle of a,c then dist(a,b) + dist(b,c) > dist(a,c), so this is a valid triple, but if b is inside dist(a,b) + dist(b,c) = dist(a,c), which makes it a bad triple.</p>
                <p>Now lets define the points as they are in the problem a = (x,i), b = (y,q), c = (z,r) where i, q, r are indices. We can see that if a bad situation were to occur that would mean that (x <= y <= z or x >= y >= z) and (i <= j <= k or i >= j >= k). However, notice that since i, j, k are indices we only need to look at the situation were i < j < k, because if we also looked at the situation where i > j > k, we would start overcounting.</p>
                <p>Now look at our first condition we can rephrase that as if there are 3 non-decreasing or 3 non-increasing numbers in order (not necessarily adjacent to each other) in a subarray, then the subarray is invalid because those numbers can form a bad triple. Now notice that because we want this condition to be true, we can limit our subarray size to 4. If there is a subarray of size 5 it is guaranteed to have 3 non-increasing or 3 non-decreasing (you can prove this yourself by bashing it out).</p>
                <p>So finally our problem reduces to checking all size 1, 2, 3, 4 subarrays in the original array, to see if they have a bad triple and if they don't add them to a count, and then at the end of the program print the count.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1237/C1">Problem 18</a>
            <details>
                <summary>Solution</summary>
                <p>Realize that n <= 2000, which means that we can have up to an n^2 solution for this problem. I am going to give the n^2 solution I used, and then prove that it is right. The solution that I used, is that n/2 times in a row I choose an arbitrary point x that hasn't been removed, then I choose the closest point to x that hasn't been removed yet, lets call it y. I choose these two points to be the pair that I remove, and this pair always work.</p>
                <p>Now lets see why. y is the closest point to x and now they form a bounding box being the top right and bottom left corners respectively. If a point was to be found in the bounding box, then that point would be closer to x than y is (because y is the farthest point in the bounding box from x). However we know that there is no point closer to x than y because we defined y to be the closest point. So the bounded box is always empty and we can always remove this pair of points, and our strategy works out in the end.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/507/B">Problem 17</a>
            <details>
                <summary>Solution</summary>
                <p>Lets call the euclidean distance between the two centers d (ie sqrt((x2-x1)^2 + (y2-y1)^2)). Notice that the maximum distance you can shift the center of the circle by is 2*R per move (done by rotating the circle by 180 degrees from any pin position). So we can see that it is optimal to move as much as possible until we are within 2*R of the center we want to find. Now notice that when we are within 2*R distance and not already at the end point, we can shift to the new center in one move (shown in diagram below). So now we can see that our optimal strategy leads to an answer of ceil(d/(2*R)).</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1458/A">Problem 16</a>
            <details>
                <summary>Solution</summary>
                <p>This problem can be easily solved if we know some GCD rules. GCD(x-y,y) = GCD(x,y), and this logic works for all arguments, so GCD(x,y,z) = GCD(x-y,y,z). Now notice that the answer we are looking for is GCD(a1+bj, a2+bj, ..., an+bj). We can subtract a1+bj from each term but the first and see that this is equal to GCD(a1+bj, a2-a1, ..., an-a1). We can precalculate GCD(a2-a1, ..., an-a1) and call it G. Now we have that the answer to every query is GCD(a1+bj, G). Note that to get G we might have to use GCD(x, 0) = 0. Also note that if a1 is not the smallest element in the sequences this does not work because then you get the GCD of a negative number.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1167/C">Problem 15</a>
            <details>
                <summary>Solution</summary>
                <p>To solve this problem we can just use the strategy of connected components where once we have a graph set up, for every not visited yet we can start a dfs from the user and everything that user can connect to will belong to the same connected component, and if they are in a certain connected component they can share information to everyone in that connected component, so for each user you just have to take the size of the connected component the user is inside of.</p>
                <p>Now we that we have the strategy we actually have to start creating the graph. Notice that if we add a edge from everyone to everyone else in each of the m groups this has n^2 edges which is too slow (to visualize this consider the case of only 1 group containing all people). So a better strategy is just to connect only adjacent people in each group as this still represents the fact that all information can spread just in a bit longer matter (but length of spread doesn't matter, only amount does). This observation reduces the complexity from n^2 to sum of k_i for each k_i in the m groups. Now that we have the optimization and the strategy we can easily solve the problem.</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/abc194/tasks/abc194_e">Problem 14</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOOn</p>
            </details>
            <br>
            <a href="../writeups/pclassicfall2021">Problem 13</a>
            <details>
                <summary>Solution</summary>
                <p>For some reason, we didn't give a POTD today, so instead you can go check out our pclassic writeups for some cool problems.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1514/C">Problem 12</a>
            <details>
                <summary>Solution</summary>
                <p>The first observation of this problem is to notice that if we include a number x < n such that gcd(x, n) != 1 then the prod wont be 1 mod N. To see this in action, imagine we have n = 9 and we include 3 in the product. Prod % 9, must be either be 0, 3, or 6 (ie a multiple of 3), and thus it will never be 1, and that is not what we want. So now we know we should only include numbers that have gcd(x, n) == 1. Lets call p the product of all numbers that have gcd(x, n) == 1 modulo n. If p == 1 we can just output all those numbers, however if p != 1, we can just remove the number p itself and output the rest of the numbers. </p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/329/B">Problem 11</a>
            <details>
                <summary>Solution</summary>
                <p>The optimal strategy for the user in this problem is to take the shortest path to the exit cell. This is because if you take a non-shortest path this gives the other trainers an extra move to try to get to you. Now notice that the optimal play for the trainers is to get to the exit cell before or at the same time as you. This is because if they can get to the exit cell, you are forced to battle them before you can leave.</p>
                <p>Notice that since you are taking the shortest path to the exit cell, only trainers that have a closer or the same length shortest path to the exit cell can battle you, while others can not. This is because if they can battle you on cell X on your route to the exit, this means they can reach cell X before or at the same time as you. And cell X is on the shortest path so they can take the shortest path from cell X and reach the exit cell before you.</p>
                <p>So now this problem boils down to checking if the shortest path to the exit of the trainers are shorter than or equal to your shortest path to the exit. If they are you have to battle them, and if they aren't you don't have to battle them. You can find the shortest path to the exit for each trainer and yourself by doing a single bfs starting at the exit cell. Once you are done with the bfs just compare distances and add up trainers and output your answer.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1538/F">Problem 10</a>
            <details>
                <summary>Solution</summary>
                <p>There are a ton of overly difficult ways to solve this problem using dp, binary search, and the such, but I am going to give the simplest solution I found here. The total number of changed digits is equal to the sum of changes in each place (ie, ones place, tens place, hundreds place). The amount of changes in the ones place is equal to R - L, you can figure this out pretty trivially. Now notice that the number of changes in the 10s place is equivalent to floor(R/10) - floor(L/10). This same pattern occurs for the rest of the places as well. So for each digit place x from 0 to 9 add to the sum floor(R/10^x) - floor(L/10^x), and output this for your answer.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1475/C">Problem 09</a>
            <details>
                <summary>Solution</summary>
                <p>This problem boils down to the following for each of the k couples in the input, find out how many other couples they can dance with, and sum all these up and then divide 2(to prevent a,b and b,a overcounting) and output them. Let freq1[a], freq2[b] be the number of times a shows up in the first sequence and the number of times b shows up in the second sequences.</p>
                <p>Notice that if our current pair is (a,b) then any pairs of the form (a,x) and (x,b) fail, the number of these failed equivalent to freq1[a] + freq[b] - 1, where the -1 exists to remove the double counting of the pair (a,b) itself (because obviously (a,b) cant dance with (a,b), they are just 1 couple not 2. but (a,b) is counted in both freq1[a] and freq2[b], so we need to remove 1 to prevent overcounting.</p>
                <p>Now we know freq1[a]+freq2[b]-1 fails which means k-(freq1[a]+freq2[b]-1) works, so our final answer is (the sum of k-(freq1[a]+freq2[b]-1)) divided by 2.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1095/C">Problem 08</a>
            <details>
                <summary>Solution</summary>
                <p>Notice that the minimum powers of 2 needed to create the number n, is the number of 1 bits in the binary representation of n, lets call this number x, and lets say we have all the powers of 2 represented by these 1 bits in a multiset S. If x > k, then our answer is NO because we can't decrease the power of 2s that we need. If x == k, we can just return the powers of 2 in S. If x < k, we need to do break up some powers of 2 into smaller powers of 2. Observe that breaking up a power of 2 increases the total count x by 1. So we can just take a value in the multiset, split it into 2 and put its components back into the set. We can do this until all values equal 1, ie there are n 1s. So this means if n < k, it we output NO, else we output whatever we had in our multiset, after we split powers of 2, k-x times.</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/agc040/tasks/agc040_c">Problem 07</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/arc116/tasks/arc116_d">Problem 06</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/abc183/tasks/abc183_e">Problem 05</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/abc196/tasks/abc196_d">Problem 04</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/arc098/tasks/arc098_b">Problem 03</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/abc149/tasks/abc149_e">Problem 02</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://atcoder.jp/contests/abc147/tasks/abc147_d">Problem 01</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
        </fieldset>
    </div>
</body>
