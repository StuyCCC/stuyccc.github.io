<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../../templates/template.css" type="text/css">
    <link rel="icon" href="../../templates/favicon.ico">
    <script src="../../templates/template.js"></script>

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../templates/gruvbox-dark-pale.min.css">
    <script src="../../templates/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>StuyCCC</title>
</head>
<body>
    <div id="side"></div>
    <div id="main">
        <h4>Last Updated 2023-01-09</h4>
        <fieldset>
            <legend>SORTING</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <h3>Sorting Algorithms</h3>
            <p>When I say sorting in this article I am considering sorting an array where the only information about the elements in the array is they can be ordered, and when comparing two elements, the smaller of the two. Algorithms using this model are called comparison sorts.</p>
            <p>The two examples, are insertion sort, a simple <script type="math/tex">\mathcal{O}(n^2)</script> sort, where <script type="math/tex">n = \text{length of the array}</script> and mergesort, a common example of an <script type="math/tex">O(n\log n)</script> sort. Both of these are described in many many places, so I won't repeat their description here. If you are in Stuyvesant, the library has a copy of <em>Algorithms</em> by Sedgewick. Also in the aformentioned text (and in many more) is a proof for the lower bound on the number of comparisons needed to sort an array with a comparison sort. That is <script type="math/tex">\mathcal{O}(n\log n)</script>.</p>
            <p>This is text to say, most introductory algorithms textbooks and many websites (I think even the wikipedia) have details on comparison sorts so I won't repeat all of it here.</p>
            <p>Also, the Stuyvesant APCS website by Mr. K has <a href="https://konstantinnovation.github.io/apcsFall.html#2022-11-30n">some good notes</a> on sorting algorithms that this page also takes heavy inspiration from.</p>

			<h3>Implementing Sorting</h3>
			<p>Before we discuss sorting algorithms, try writing one yourself. Try coding something that takes in an array of numbers from input and sorts it in ascending order.</p>

			<h4>Bubble Sort</h4>
			<p>This is one of the slowest sorting algorithms out there, but it's easy to implement and is a good introduction to algorithms in general.</p>
			<ol>
				<li>Set an end variable, j, to the length of the array - 1</li>
				<li>Set i to 0</li>
				<li>Compare a[i] with a[i+1], if its out of order (ie. a[i] > a[i+1]), swap them</li>
				<li>Repeat Steps 2 & 3 until i == j</li>
				<li>Now the last term (a[j+1]) is in order, decrease j</li>
				<li>If no swaps were performed to get a[j+1] in order, the array is sorted, and end here</li>
				<li>Otherwise, decrease j by 1 to get a[j] correct, then repeat Steps 2-6 until j is 0 (ie. loop while j >= 1)</li>
			</ol>

			<h3>Using sorting in C++</h3>
			<p>Thankfully, C++ has built-in sorting algorithms so you don't have to implement it yourself, there's <code>qsort(pointer, element count, size of element</code> for arrays and <code>sort(iterator, iterator)</code> for other classes, examples:</p>
<pre><code class="language-cpp">
#include &ltalgorithm&gt
#include &ltvector&gt
#include &ltiostream&gt

using namespace std;

int a[6] = {7, -1, 2, 6, -10, 4};
qsort(a, 6, sizeof(int));
for(int i = 0; i &lt 6; ++i){
	cout &lt&lt a[i] &lt&lt ", ";
}
cout &lt&lt endl;
// should print [-10, -1, 2, 4, 6, 7]
vector&ltint&gt v;
v.push_back(7);
v.push_back(-1);
v.push_back(2);
v.push_back(6);
v.push_back(-10);
v.push_back(4);
sort(v.begin(), v.end());
for(auto it = v.begin(); it != v.end(); it++){
	cout &lt&lt *it &lt&lt ", ";
}
cout &lt&lt endl;
// should print [-10, -1, 2, 4, 6, 7]
</code></pre>
			<h3>Sorting Questions</h3>
            <h4><a href="https://codeforces.com/problemset/problem/1561/C">Sort (and sort again, or binary search)</a></h4>
            <p>In the interest of not repeating what is already on the internet I will link to the editorial <a href="https://codeforces.com/blog/entry/94216">here</a>. I will write though that the strategy of finding a way to check a solution and then binary searching over the answer is a common strategy. In this problem it manifests as finding the best order to visit caves in, what level the hero must be to enter a cave, and how many levels the hero will gain from clearing a cave and then binary searching over all possible starting levels.</p>
            <h4><a href="https://codeforces.com/problemset/problem/1545/A">Sorting and a Clever Observation</a></h4>
            <p>This question can be pretty hard. I'd start with it by playing around with swapping people to the left and to the right. The thing to notice, is for a person to continue facing right it must be the case they are swapped an even number of times. Every time a person is swapped they change the direction they are facing so to keep them facing the same direction they haved to be swapped twice, once for one change in direction and another time to fix that change.</p>
            <p>The clever realization is realizing what this means about the parity (evenness or oddness) of the index of a person. It is invarient! If a person starts at an even index, they must end at an even index if they are to face right. This is because they must be swapped twice. Two swaps means the person moves either 2 indexes to the left, 2 indexes to the right, or doesn't move at all. 2 plus (or minus) an odd number is odd, and 2 plus (or minus) an even number is even, so the parity is invariant.</p>
            <p>Therefore after the people are sorted in non-decreasing order and are all facing to the right, each person at an odd index will still have an odd index and each person with an even index will still have an even index. This means after sorting all the numbers at odd indices and then sorting all the numbers at even indices, it should be the case the array is in non-decreasing order. If so then the rearrangement desired by the question is possible, if not it is impossible.</p>
            <p>This can be implemented by splitting the array into two, one of evens index numbers and one of odd index numbers, and sorting each of those arrays separately. Then these arrays can be recombined element by element into one array.</p>
            <p>One thing I brushed over is how it is known there exists an algorithm to sort only the even indexed elements in an array. It is the case that algorithm exists. Consider an algorithm like insertion sort (or even bubble sort). The only way it modifies the array is by swapping adjacent elements and yet it can still finish sorting the array. That means if it is possible to swap any two elements with indices two apart, it should be possible to sort only the elements with even (or odd) indices. I'll leave showing this to you, dear reader. It isn't that hard too show by looking at a sequence of three numbers and playing around trying to swap the two numbers with a number in the middle of them. Just playing around with small samples like is often incredibly useful when solving problems, even if the end goal isn't in site at that moment.</p>
        </fieldset>
    </div>
</body>
